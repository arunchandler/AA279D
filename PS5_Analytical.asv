clc; clear; close all;
addpath mean_osc          % your helper folder
format long g

%% ---------- constants & helpers ----------
global tol Re J2 mu s_d
tol = 1e-10;
Re  = 6378137;             J2  = 1.082626e-3;
mu  = 3.986004418e14;      s_d = 86400;

vcol = @(x) x(:);          % force column
vrow = @(x) x(:).';        % force row
wrap = @(x) wrapTo2Pi(mod(x,2*pi));

%% ---------- chief initial orbit ----------
a_TSX    = 6886536.686;    e_TSX = 0.0001264;
i_TSX    = deg2rad(97.4453);
RAAN_TSX = deg2rad(351.0108);
omega_TSX= deg2rad(101.2452);
M_TSX    = deg2rad(11.6520);

TSX_init = [a_TSX e_TSX i_TSX RAAN_TSX omega_TSX M_TSX];

%% ---------- deputy init from ROE target ----------
roe_tgt = [0;0;
           500*cosd(80); 500*sind(80);
           300*cosd(50); 300*sind(50)];
[TDX_init,~]= safe_qns2oe(TSX_init, roe_tgt');

%% ---------- grids & limits ----------
n  = sqrt(mu/a_TSX^3);     T = 2*pi/n;
sim_days  = 2;
t_grid    = linspace(0,sim_days*s_d,1e4+1).';   % 10 000 samples
dt        = t_grid(2)-t_grid(1);

a_chief   = a_TSX;
de_max_m  = 10;             di_max_m = 2;
de_max    = de_max_m/a_chief;
di_max    = di_max_m/a_chief;
e_nom_hat = roe_tgt(3:4)/a_chief;
i_nom_hat = roe_tgt(5:6)/a_chief;

i_c       = i_TSX;
lambda_nom_hat = roe_tgt(2)/a_chief;
u_nom_hat = lambda_nom_hat - (i_nom_hat(2))*cot(i_c);

% Fix tolerance to be smaller than the error thresholds
tol_maneuver = 1e-10;  % Much smaller than the error thresholds

%% ---------- state arrays ----------
N    = numel(t_grid);
TSX  = zeros(N,6);    TSX(1,:) = TSX_init;
TDX  = zeros(N,6);    TDX(1,:) = TDX_init;
rel  = zeros(N,6);

rel(1,:) = a_chief * compute_roes(TSX_init,TDX_init)';   % <-- add this

%% ---------- bookkeeping ----------
pending  = [];                     % burn queue
burn_t   = []; burn_dv=[]; burn_vecs=[];
cum_dv   = 0;
maneuver_log = [];
cooldown = T;                    % 2-orbit cool-down (increased from 1)
last_plan= -Inf;
use_N    = true;                   % permit normal burn?

% ---- queue helper ----
next_burn = @(u_tgt,u_now,t_now,nbar) ...
            find_next_burn_time(u_tgt, u_now, t_now, nbar);

J = 2;                       % how many samples before & after to print
watch = false(N,1);          % logical vector, all false to start

%% ---------- MAIN LOOP (fixed-grid) ----------
for k = 2:N
    t_prev = t_grid(k-1);  t_cur = t_grid(k);

    %-------------------------------------------------- 1. propagate full step
    [~,c_tmp]=ode4(@compute_rates_GVE_J2,[t_prev t_cur]',TSX(k-1,:)',dt);
    [~,d_tmp]=ode4(@compute_rates_GVE_J2,[t_prev t_cur]',TDX(k-1,:)',dt);
    chief = vrow(c_tmp(end,:));    dep = vrow(d_tmp(end,:));

    %-------------------------------------------------- 2. execute queued burns
    while ~isempty(pending) && pending(1).t <= t_cur+1e-9
        tburn = pending(1).t;  dv_rtn = pending(1).dv_rtn;  label=pending(1).tag;

        % rewind to burn, kick, propagate rest of step
        [~,c_tmp]=ode4(@compute_rates_GVE_J2,[t_prev tburn]',chief',dt/10);
        [~,d_tmp]=ode4(@compute_rates_GVE_J2,[t_prev tburn]',dep'  ,dt/10);
        chief = vrow(c_tmp(end,:));    dep = vrow(d_tmp(end,:));
        roe_before = a_chief * compute_roes(chief,dep)';
        
        % Convert RTN to ECI at burn time using current deputy state
        rv_dep = oe2rv(dep, mu);
        r_dep = rv_dep(1:3);
        v_dep = rv_dep(4:6);
        dv_eci = dv_RTN2ECI(r_dep, v_dep, dv_rtn);
        
        dep   = vrow(kick(dep,dv_eci));
        roe_after  = a_chief * compute_roes(chief,dep)';     % just after kick
        dR = roe_after - roe_before;
        
        fprintf('  ΔROE = [%6.2f %6.2f %6.2f %6.2f %6.2f %6.2f] m\n',...
                dR(1),dR(2),dR(3),dR(4),dR(5),dR(6));

        [~,c_tmp]=ode4(@compute_rates_GVE_J2,[tburn t_cur]',chief',dt/10);
        [~,d_tmp]=ode4(@compute_rates_GVE_J2,[tburn t_cur]',dep'  ,dt/10);
        chief = vrow(c_tmp(end,:));    dep = vrow(d_tmp(end,:));

        % -- bookkeeping
        burn_t   = [burn_t; tburn];
        burn_dv  = [burn_dv; norm(dv_eci)];
        burn_vecs= [burn_vecs; get_rtn_components(dep,dv_eci)];
        cum_dv   = cum_dv + norm(dv_eci);

        fprintf('Executed %s burn  t=%9.1f s  |Δv|=%6.2f mm/s\n',...
                label,tburn,norm(dv_eci)*1e3);

        pending(1)=[];   t_prev = tburn;   % popped & time shifted
    end

    %-------------------------------------------------- 3. store grid sample
    TSX(k,:) = chief;  TSX(k,6)=wrapTo2Pi(TSX(k,6));
    TDX(k,:) = dep;    TDX(k,6)=wrapTo2Pi(TDX(k,6));
    rel(k,:) = a_chief*compute_roes(chief,dep)';
    if watch(k) && k>1
        dROE = rel(k,:) - rel(k-1,:);
        fprintf('t = %8.1f  ΔROE = [%6.2f %6.2f %6.2f %6.2f %6.2f %6.2f] m\n',...
                t_cur, dROE(1),dROE(2),dROE(3),dROE(4),dROE(5),dROE(6));
    end

    %-------------------------------------------------- 4. plan new manoeuvre?
    if isempty(pending) && (t_cur-last_plan)>=cooldown
        roe_hat = compute_roes(chief,dep)';
        de_hat  = vcol(roe_hat(3:4));   di_hat = vcol(roe_hat(5:6));
        de_err  = norm(de_hat-e_nom_hat);
        di_err  = norm(di_hat-i_nom_hat);
    
        % Add small tolerance to avoid floating point issues
        tol_maneuver = 1e-10;  % Much smaller than the error thresholds
        need_e_maneuver = de_err > (de_max + tol_maneuver);
        need_i_maneuver = di_err > (di_max + tol_maneuver);
    
        if need_e_maneuver || need_i_maneuver
            fprintf('\n=== Maneuver Planning Debug ===\n');
            fprintf('Current e-vector: [%.6f, %.6f] (dimensionless)\n', de_hat(1), de_hat(2));
            fprintf('Nominal e-vector: [%.6f, %.6f] (dimensionless)\n', e_nom_hat(1), e_nom_hat(2));
            fprintf('de_err = %.9f, de_max = %.9f (need_e_maneuver = %d)\n', de_err, de_max, need_e_maneuver);
            fprintf('di_err = %.9f, di_max = %.9f (need_i_maneuver = %d)\n', di_err, di_max, need_i_maneuver);
    
            % -------- secular mean-motion --------
            eta   = sqrt(1-chief(2)^2);
            gamma = 0.5*J2*(Re/a_chief)^2/eta^4;
            P=3*cos(chief(3))^2-1; Q=5*cos(chief(3))^2-1;
            kappa=0.75*J2*Re^2*sqrt(mu)/(a_chief^(7/2)*eta^4);
            nbar = n+kappa*(eta*P+Q);
    
            % -------- current argument of latitude --------
            u_c  = wrapTo2Pi( mean2true(chief(6),chief(2),tol)+chief(5) );
    
            % Initialize burn queue for this maneuver cycle
            new_burns = [];
            
            % -------- ECCENTRICITY MANEUVERS --------
            if need_e_maneuver
                % target vectors (2.58-2.62)
                phi_d = 1.5*gamma*(5*cos(chief(3))^2-1);
                dphi  = sign(phi_d)*asin(de_max/norm(e_nom_hat));
                Rz    = [cos(dphi) -sin(dphi); sin(dphi) cos(dphi)];
                de_man= Rz*e_nom_hat;
                de_req = vcol(de_man)-de_hat;
                
                fprintf('Target e-vector:  [%.6f, %.6f] (dimensionless)\n', de_man(1), de_man(2));
                fprintf('Rotation angle: %.2f deg\n', rad2deg(dphi));
                
                % burn epochs
                uM1  = atan2(de_req(2),de_req(1));
                uM2  = wrapTo2Pi(uM1+pi);
                t1   = next_burn(uM1,u_c,t_cur,nbar);
                t2   = next_burn(uM2,u_c,t_cur,nbar);
            
                % Δv magnitudes
                nu_d = mean2true(dep(6),dep(2),tol);
                u_d  = wrapT(nu_d+dep(5));
                delta_u = wrapToPi(u_d-u_c);
            
                Delta_t = 1*T;
                du_J2 = -12*gamma*sin(2*chief(3))*di_hat(1)*n*Delta_t;
                da_man = -pi/(2*n*Delta_t-pi) * ...
                         (3*de_max+roe_hat(1) - (4/(3*pi))*(delta_u-u_nom_hat+du_J2));
            
                dvt1 = n*a_chief/4*((da_man-roe_hat(1))+norm(de_req));
                dvt2 = -dvt1;
                
                fprintf('Target da: %.6f (current: %.6f)\n', da_man, roe_hat(1));
                
                % Add numerical bounds checking
                max_dv = 0.1;  % Maximum 10 cm/s per burn
                dvt1 = sign(dvt1) * min(abs(dvt1), max_dv);
                dvt2 = sign(dvt2) * min(abs(dvt2), max_dv);
            
                % Store RTN components for later conversion at burn time
                new_burns = [new_burns;
                            struct('t',t1,'dv_rtn',[0; dvt1; 0],'tag','T1');
                            struct('t',t2,'dv_rtn',[0; dvt2; 0],'tag','T2')];
                
                fprintf('Planned eccentricity maneuvers: T1 at t=%.1f, T2 at t=%.1f\n', t1, t2);
            end
            
            % -------- INCLINATION MANEUVERS --------
            if need_i_maneuver && use_N
                di_max_new = di_max+abs(3*gamma*di_hat(1)*pi*sin(chief(3))^2);
                di_man = [i_nom_hat(1); i_nom_hat(2)-sign(di_hat(1))*di_max_new];
                di_req = vcol(di_man)-di_hat;
            
                fprintf('Current i-vector: [%.6f, %.6f] (dimensionless)\n', di_hat(1), di_hat(2));
                fprintf('Target i-vector:  [%.6f, %.6f] (dimensionless)\n', di_man(1), di_man(2));
            
                uN = wrapTo2Pi(atan2(di_req(2),di_req(1)));
                tn = next_burn(uN,u_c,t_cur,nbar);
                dvn = n*a_chief*norm(di_req);
                
                % Add numerical bounds checking for inclination maneuver
                max_dv_n = 0.1;  % Maximum 10 cm/s per burn
                dvn = sign(dvn) * min(abs(dvn), max_dv_n);
            
                % Store RTN components for later conversion at burn time
                new_burns = [new_burns;
                            struct('t',tn,'dv_rtn',[0; 0; dvn],'tag','N')];
                
                fprintf('Planned inclination maneuever: N at t=%.1f\n', tn);
            end
    
            % -------- Add all burns to pending queue --------
            pending = [pending; new_burns];
            
            % sort queue by time
            [~,ix] = sort([pending.t]);  pending = pending(ix);
    
            % -------- Bookkeeping --------
            dvt1_log = 0; dvt2_log = 0; dvn_log = 0;
            if need_e_maneuver
                dvt1_log = dvt1; dvt2_log = dvt2;
            end
            if need_i_maneuver && use_N
                dvn_log = dvn;
            end
            
            maneuver_log = [maneuver_log;
               struct('t_det',t_cur,'de_error',de_err*a_chief,'di_error',di_err*a_chief,...
                      'dvt1',dvt1_log,'dvt2',dvt2_log,'dvn',dvn_log)];
            last_plan = t_cur;
            
            fprintf('Planned manoeuvre at t=%8.1f s (queue size %d)\n',...
                    t_cur,numel(pending));
    
            % -------- Set watch flags --------
            all_burn_times = [new_burns.t];
            for tburn = all_burn_times
                idx_burn = round( (tburn - t_grid(1))/dt ) + 1;   % nearest grid index
                idx_lo   = max(1, idx_burn - J);
                idx_hi   = min(N, idx_burn + J);
                watch(idx_lo:idx_hi) = true;                      % flag the window
            end
        end
    end
end % ---- end for k ----



%% ---------- RESULTS & PLOTS ----------
fprintf('\nTotal manoeuvres planned: %d\n',numel(maneuver_log));
fprintf('Total Δv = %.3f m/s   (%.3f m/s per day)\n',...
        cum_dv, cum_dv/sim_days);

% ---- ROE evolution (each in its own axis) ----
figure('Name','ROE evolution','Color','w');
labels = {'a·δa [m]','a·δλ [m]','a·δe_x [m]','a·δe_y [m]',...
          'a·δi_x [m]','a·δi_y [m]'};
for i = 1:6
    subplot(3,2,i)
    plot(t_grid/86400,rel(:,i),'LineWidth',1.2);
    ylabel(labels{i}); grid on
    if i==1, title('Relative Orbital Elements vs time'); end
    if i>4,  xlabel('Time [day]'); end
end

% ---- cumulative Δv ----
cum_hist = zeros(N,1);
for i = 1:N
    cum_hist(i) = sum(burn_dv(burn_t<=t_grid(i)));
end
figure('Name','Cumulative Δv','Color','w');
plot(t_grid/86400,cum_hist,'LineWidth',1.6); grid on
ylabel('ΣΔv  [m/s]'); xlabel('Time [day]');
title('Total Δv consumption');

% Show maneuver details
if ~isempty(maneuver_log)
    fprintf('\n=== MANEUVER DETAILS ===\n');
    fprintf('%-8s %-12s %-12s %-12s %-12s\n', 'Maneuver', 'Orbit', 'de_error', 'di_error', 'Total_dV');
    fprintf('%-8s %-12s %-12s %-12s %-12s\n', '-------', '-----', '--------', '--------', '--------');
    
    for i = 1:length(maneuver_log)
        det = maneuver_log(i);
        orbit_num = det.t_det / T;
        total_dv = abs(det.dvt1) + abs(det.dvt2);
        if isfield(det, 'dvn')
            total_dv = total_dv + det.dvn;
        end
        fprintf('%-8d %-12.2f %-12.2f %-12.2f %-12.4f\n', ...
                i, orbit_num, det.de_error, det.di_error, total_dv);
    end
end

%% Helper Functions

function t_burn = find_next_burn_time(u_tgt, u_now, t_now, nbar)
    % Find the next time when the satellite reaches the target argument of latitude
    % Uses a search structure similar to damico_maneuvers function
    k = 0;
    t_burn = -100;
    
    while t_burn < t_now
        u_target = u_tgt + k*2*pi;  % Add full revolutions to find next occurrence
        t_burn = t_now + (u_target - u_now)/nbar;
        k = k + 1;
        
        % Safety check to prevent infinite loops
        if k > 100
            error('Could not find valid burn time within 100 revolutions');
        end
    end
end

function dirECI = rtn_axis(oeChief, oeDep, which)
    global mu tol
    rvC = oe2rv(oeChief, mu);
    rvD = oe2rv(oeDep, mu);
    [R,T,N] = eci2rtn_dir(rvD(1:3), rvD(4:6));
    switch upper(which)
        case 'R', dirECI = R(:);
        case 'T', dirECI = T(:);
        otherwise, dirECI = N(:);
    end
end

function [R,T,N] = eci2rtn_dir(r, v)
    R = r(:).' / norm(r);
    h = cross(r, v);
    N = h(:).' / norm(h);
    T = cross(N, R);
end

function oeNew = kick(oeRow, dvECI)
    global mu tol
    rv = oe2rv(oeRow, mu);  % Just pass the orbital elements as-is!
    rv(4:6) = rv(4:6) + dvECI(:);
    oe = safe_rv2oe(rv, mu);
    oeNew = [oe(1:5) safe_true2mean(oe(6), oe(2))];
end

function rtn_components = get_rtn_components(oe_dep, dv_vec)
    global mu tol
    rv_dep = oe2rv(oe_dep, mu);
    r_dep = rv_dep(1:3);
    v_dep = rv_dep(4:6);
    [Rhat, That, Nhat] = eci2rtn_dir(r_dep, v_dep);
    
    dv_R = dot(dv_vec, Rhat);
    dv_T = dot(dv_vec, That);
    dv_N = dot(dv_vec, Nhat);
    
    rtn_components = [dv_R dv_T dv_N];
end

function delta_v_ECI = dv_RTN2ECI(r_ECI, v_ECI, delta_v_RTN)
    % Normalize R = radial direction (along position)
    R_hat = r_ECI / norm(r_ECI);
    R_hat = R_hat(:);

    % N = orbit normal direction = r × v
    N = cross(r_ECI, v_ECI);
    N_hat = N / norm(N);
    N_hat = N_hat(:);

    T_hat = cross(N_hat, R_hat);
    T_hat = T_hat(:);

    % Construct rotation matrix from RTN to ECI
    Q_RTN2ECI = [R_hat, T_hat, N_hat];

    delta_v_ECI = Q_RTN2ECI * delta_v_RTN;
end