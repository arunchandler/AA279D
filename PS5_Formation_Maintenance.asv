clc; clear; close all;
addpath('mean_osc');
format long g;

global tol Re J2 mu s_d
% Tolerances and constants
 tol = 1e-9;           % numerical tolerance
 Re = 6378137;         % Earth radius [m]
 J2 = 1.082626e-3;     % J2 coefficient
 mu = 3.986004418e14;  % gravitational parameter [m^3/s^2]
 s_d = 86400;          % seconds per day

%% Scenario Selection
scenario = input(...
    ['Select rel_qns_init scenario:\n' ...
     '  1: DEM formation (e_term=122/√2)\n' ...
     '  2: Example “circular” formation\n' ...
     '  3: Custom (enter manually)\n' ...
     'Your choice: '] );

switch scenario
    case 1
        e_term = 122/sqrt(2);
        rel_qns_init = [0, 340, e_term, e_term, 0, 256];
        scenario_name = 'DEM';
    case 2
        e_term = 4982/sqrt(2);
        rel_qns_init = [0, -76050, e_term, e_term, 80, 0];
        scenario_name = 'Pursuit';
    case 3
        e_term = 3600/sqrt(2);
        rel_qns_init = [0, 0, e_term, e_term, 250, 0];
        scenario_name = 'Large cross-track';
    case 4
        e_term = 250/sqrt(2);
        rel_qns_init = [0, -340, e_term, e_term, 250, 0];
        scenario_name = 'Short baseline';
    case 5
        rel_qns_init = [0, 0, 0, 300, 0, -1000];
        scenario_name = 'Damico Paper Initialization';
    otherwise
        error('Invalid scenario');
end
fprintf('Running scenario "%s": rel_qns_init = [%g %g %g %g %g %g]\n\n', scenario_name, rel_qns_init);

% Chief initial orbital elements
a_TSX_init    = 6892944.65;    % semi-major axis [m]
e_TSX_init    = 0.00013700;    % eccentricity
i_TSX_init    = deg2rad(97.440124); % inclination [rad]
RAAN_TSX_init = deg2rad(104.274891);
omega_TSX_init= deg2rad(67.975723);
M_TSX_init    = deg2rad(292.169756);
nu_TSX_init   = mean2true(M_TSX_init, e_TSX_init, tol);
u_TSX_init   = nu_TSX_init;     % true anomaly
TSX_init_oe   = [a_TSX_init, e_TSX_init, i_TSX_init, RAAN_TSX_init, omega_TSX_init, M_TSX_init];

% Deputy initial orbital elements
TDX_init_oe = qns2oe(TSX_init_oe, rel_qns_init);

%% Time grid and chief propagation
tstart  = 0;
n       = sqrt(mu/a_TSX_init^3);
T       = 2*pi/n;
tend    = 30 * s_d;         % 30 days in seconds
num_points = 10000;
dt      = (tend - tstart)/(num_points-1);
t_grid  = linspace(tstart, tend, num_points).';
t_orbit = t_grid / T;

% Precompute chief trajectory under J2
[~, TSX_oe] = ode4(@compute_rates_GVE_J2, [tstart, tend], TSX_init_oe', dt);
TSX_oe(:,6) = wrapTo2Pi(TSX_oe(:,6));

%% Preallocate deputy (controlled) and performance logs
TDX_oe_ctrl   = zeros(num_points,6);
TDX_oe_ctrl(1,:) = TDX_init_oe;
rel_oe_ctrl   = zeros(num_points,6);
dv_series     = zeros(num_points,1);  % Δv at each step
maneuver_flag = zeros(num_points,1);  % 0=no burn, 1=1st burn, 2=2nd burn
maneuver_schedule = [];             % to hold scheduled burns

% Control parameters
a = a_TSX_init;
roe_target   = [0; 0; 0; 300; 0; -1000];  % desired ROE [m]
angle_thresh_deg = 7;

TM_days      = 2;                     % check interval [days]
TM_sec       = TM_days * s_d;         % seconds
cycle_step   = round(TM_sec/dt);      % samples per cycle
check_idxs   = cycle_step : cycle_step : num_points;


%% Simulation loop with integrated burns
for idx = 2:num_points
    % Propagate deputy one timestep
    tspan = [t_grid(idx-1), t_grid(idx)];
    [~, oe_temp] = ode4(@compute_rates_GVE_J2, tspan, TDX_oe_ctrl(idx-1,:)', dt);
    oe_new = oe_temp(end,:);
    oe_new(6) = wrapTo2Pi(oe_new(6));
    TDX_oe_ctrl(idx,:) = oe_new;
    
    % Compute relative ROEs
    rel = a * compute_roes(TSX_oe(idx,:), oe_new)';
    rel_oe_ctrl(idx,:) = rel;
    
    % only at your 2‑day checks, compute & schedule two‑pulse
      if ismember(idx, check_idxs)
        % 1) compute current e/i error at idx
        rel_now     = rel_oe_ctrl(idx,:)';  
        delta_e_err = (rel_now(3:4) - roe_target(3:4))/a;
        delta_a_err = (rel_now(1)    - roe_target(1))   /a;
    
        % 2) Gauss formula for two tangential impulses
        v_chief = sqrt(mu/a);
        dvt1    =  (v_chief/4)*( norm(delta_e_err) + delta_a_err );
        dvt2    = -(v_chief/4)*( norm(delta_e_err) - delta_a_err );
    
        % 3) pick their phasing in argument of latitude
        u1 = atan2(delta_e_err(2), delta_e_err(1));
        u2 = mod(u1 + pi, 2*pi);
    
        % 4) convert u1,u2 to sample indices idx1, idx2
        M_c   = wrapTo2Pi(TSX_oe(idx,6));
        nu_c  = mean2true(M_c, TSX_oe(idx,2), tol);
        u_c   = wrapTo2Pi(nu_c + TSX_oe(idx,5));
        du1   = wrapTo2Pi(u1 - u_c);
        t1    = t_grid(idx) + du1 / n;
        [~, idx1] = min(abs(t_grid - t1));
        % now at idx1 compute u_c1, find idx2 similarly:
        M_c1   = wrapTo2Pi(TSX_oe(idx1,6));
        nu_c1  = mean2true(M_c1, TSX_oe(idx1,2), tol);
        u_c1   = wrapTo2Pi(nu_c1 + TSX_oe(idx1,5));
        du2    = wrapTo2Pi(u2 - u_c1);
        t2     = t_grid(idx1) + du2 / n;
        [~, idx2] = min(abs(t_grid - t2));
    
        maneuver_schedule = [ maneuver_schedule; struct( ...
            'idx1', idx1, 'idx2', idx2, ...
            'dvt1', dvt1,  'dvt2', dvt2 ) ];
        fprintf('Cycle @ idx=%d: scheduled burns @ %d & %d\n', idx, idx1, idx2);
      end
    
    for m = 1:numel(maneuver_schedule)
        if idx==maneuver_schedule(m).idx1 || idx==maneuver_schedule(m).idx2
          % same RTN Δv‑application you already wrote:
          dvi = ( idx==maneuver_schedule(m).idx1 ) ...
                 ? maneuver_schedule(m).dvt1 ...
                 : maneuver_schedule(m).dvt2;
          oe_t = TDX_oe_ctrl(idx,:);
          nu_d = mean2true(oe_t(6), oe_t(2), tol);
          rv   = oe2rv([oe_t(1:5),nu_d],mu);
          r    = rv(1:3); v  = rv(4:6);
          N_hat = cross(r,v)/norm(cross(r,v));
          R_hat =  r/norm(r);
          T_hat = cross(N_hat,R_hat);
          v_new = v + dvi*T_hat;
          oe_full = rv2oe([r;v_new],mu);
          M_new   = true2mean(oe_full(6), oe_full(2));
          TDX_oe_ctrl(idx,:) = [oe_full(1:5), M_new];
          dv_series(idx)     = abs(dvi);
          maneuver_flag(idx) = (idx==maneuver_schedule(m).idx1) + 1;
          fprintf('  --> Applied burn %d at idx=%d, Δv=%.3f m/s\n',...
                  maneuver_flag(idx), idx, dv_series(idx));
        end
    end
end
end

%% Performance Visualization
% 1) Control Tracking Error
err = vecnorm(rel_oe_ctrl - roe_target', 2, 2);
figure;
plot(t_orbit, err); grid on;
xlabel('Orbits'); ylabel('||rel error|| [m]'); title('Control Tracking Error');

% 2) Maneuver Scheduling
figure;
stem(t_orbit(maneuver_flag>0), maneuver_flag(maneuver_flag>0), 'filled'); grid on;
xlabel('Orbits'); ylabel('Stage'); title('Maneuver Scheduling');

% 3) Δv Over Time
figure;
stairs(t_orbit, dv_series); grid on;
xlabel('Orbits'); ylabel('Δv [m/s]'); title('Delta-v Time History');
